## 指令

指令包含CPU的指令，gcc、gas的指令，gcc和gas的指令是帮助将CPU指令更好的翻译成二进制文件，在汇编中则用不到gcc的指令

CPU指令参考具体的CPU ISA Manual

GAS（GNU as）指令（所有架构通用）：https://www.sourceware.org/binutils/docs-2.12/as.info/Pseudo-Ops.html#Pseudo%20Ops

> **ISA：arm指令集** 
>
> **IA-32：i386指令集** 
>
> **IA-64：Itanium指令集（64位）**
>
> **x86_64：amd指令集架构（64位兼容32位）**

Armv8-A 支持三种指令集：A32、T32 和 A64。

在 AArch64 执行状态下执行时使用 A64 指令集。它是一个长度为 32 位的指令集。名称中的“64”是指使用该指令在AArch64 执行状态，而不是指内存中指令的大小。

A32 和 T32 指令集也分别称为“ARM”和“Thumb”。

这些指令集在 AArch32 执行状态下执行时使用。在本指南中，我们不涉及 A32 和 T32 指令集。要了解有关这些说明的更多信息，请参阅本指南的相关信息部分。

### 六种寄存器

#### 通用寄存器

该架构提供了 31 个通用寄存器。每个寄存器可用作 64 位 X 寄存器（X0..X30），或用作 32 位 W 寄存器(W0..W30)。这是查看同一寄存器的两种不同方式。例如，寄存器图显示W0是X0的低32位，W1是X1的低32位

有一组单独的 32 个寄存器用于浮点和向量运算。这些寄存器是 128 位的，但与通用寄存器一样，可以通过多种方式访问。Bx 为 8 位，Hx 为 16 位，Sx 为 32 位，Dx 为 64 位，Qx 为 128 位。

这些寄存器也可以称为 V 寄存器。使用V形式时，寄存器为被视为一个向量。这意味着它被视为包含多个独立值，而不是单个值。



#### 其他寄存器

零寄存器 ZXR 和 WZR 始终读为 0 并忽略写入。

您可以使用堆栈指针 (SP) 作为加载和存储的基址。你也可以使用具有有限数据处理指令集的堆栈指针，但它不是常规的通用寄存器。

Armv8-A 有多个堆栈指针，每一个都与一个特定的异常级别相关联。

在指令中使用 SP 时，表示当前堆栈指针。

异常模型解释了如何选择堆栈指针。

X30 用作链接寄存器，可称为 LR。



程序计数器 (PC) 不是 A64 中的通用寄存器，不能与数据处理指令。可以使用以下方法读取 PC：

ADR Xd, .

ADR 指令返回标签的地址，根据当前位置计算。点 ('.') 的意思是“这里”，所以显示的指令是返回它自己的地址。这是相当于读PC。一些分支指令和一些加载/存储操作，隐式使用 PC 的值。



**注意：在 A32 和 T32 指令集中，PC 和 SP 是通用寄存器。在 A64 指令集中不是这种情况**

**注意：单独的寄存器 ELR_ELx 用于从异常中返回**



#### 系统寄存器

数据处理或加载 / 存储指令不能直接使用系统寄存器。反而，系统寄存器的内容需要读入 X 寄存器，操作，然后写回系统寄存器。有两个访问系统的说明

MRS Xd, \<system register\>

将系统寄存器读入 Xd

MSR \<system register\>, Xn

将 Xn 写入系统寄存器



系统寄存器名称以 \_ELx 结尾。\_ELx 指定访问寄存器所需的最低权限。尝试访问权限不足的寄存器会导致异常

**注意:有时您会看到 _EL12 或 _EL01 。这些用作虚拟 化的一部分。**



#### 数据处理指令

格式

operation destination，input register，input register or constant

operation：这定义了指令的作用。例如, ADD 做加法和 AND 执行逻辑与。
可以将 S 添加到操作中以设置标志。例如, ADD 变为 ADDS 。这告诉处理器根据指令的结果更新 ALU 标志。我们讨论生成条件代码部分中的 ALU 标志。

destination：指令的目标始终是一个寄存器,并指定在哪里操作的结果被放置。大多数指令都有一个目标寄存器。一些指令有两个目标寄存器。当目标是 W 寄存器时,高位对应 X 寄存器的 32 位设置为 0 。

Operand 1：这将始终是一个寄存器。这是指令的第一个输入

Operand 2：这将是一个寄存器或常数,是指令的第二个输入。当操作数 2 是寄存器时,它可能包括一个可选的移位。当操作数 2 是一个常数时,它在指令本身内被编码。这意味着可用的常数范围是有限的。



### 数据处理

#### 浮点数

浮点运算遵循与整数数据处理指令相同的格式,并且使用浮点寄存器。与整数数据处理指令一样，操作决定了所使用的寄存器的大小。浮点运算部分指令总是以 F 开头。例如,此指令将 H0 = H1 / H2 设置为一半精确:

FDIV H0, H1, H2
该指令以单精度设置 S0 = S1 + S2 :
FADD S0 S1 S2
该指令以双精度设置 D0 = D1 - D2



#### 位操作



![Screenshot from 2021-06-01 19-42-36](https://i.loli.net/2021/06/02/DR1BPA4UmefFYEw.png)

BFI指令将位域插入寄存器。在上图中, BFI 取 6位来自源寄存器 (W0) 的位字段并将其插入目标中的第 9 位登记。
UBFX 提取一个位域。在上图中, UBFX 从第 18 位开始取一个 7 位字段在源寄存器中,并将其放置在目标寄存器中

WZR 是零登记。
上图中的最后一个例子取了 WZR 的低 4 位,并将它们插入到位W1 的位置 3 。



![Screenshot from 2021-06-01 19-45-56](https://i.loli.net/2021/06/02/YHibNsjMedCL8l1.png)

REV16 指令反转 W 寄存器中的两个半字( 16 位)。在上图中,有一条指令将整个寄存器中的字节反转



#### 扩展与饱和

在第一条指令 SXTB 中, B 表示字节。它需要 W0 的底部字节和符号扩展
到 32 位。
UXTH 是半字 (H) 的无符号扩展。它需要 W1 的底部 16 位和零
将其扩展到 32 位

![Screenshot from 2021-06-01 19-48-52](https://i.loli.net/2021/06/02/pRCmBxkKPdV3Gnj.png)

对于表中的 16 位示例,需要额外的指令。中的第三个例子table 接受 16 位输入,将它们扩展到 32 位,然后执行加法。这序列将 16 位输入转换为 32 位,使用:
SXTH W8,W1
然后,此指令执行加法并将结果饱和为有符号的 16 位:
添加 

W0,W8,W0,SXTH

将 , SXTH 添加到 ADD 操作的操作数列表的末尾会导致结果使用饱和算术。因为目标是 W 寄存器,所以 ADD 将饱和为 16 位整数范围。



#### 格式转换

我们已经看到 MOV 和 MVN 指令将值从一个寄存器复制到另一个寄存器。类似地, FMOV 可用于在浮点寄存器和通用寄存器之间进行复制。但是,使用 FMOV 会在寄存器之间复制文字位模式。还有可以转换为最接近表示的指令,如下图所示

![Screenshot from 2021-06-01 19-51-40](https://i.loli.net/2021/06/02/SnYBpbegOVChPvd.png)

#### 矢量数据

A64架构还提供对矢量数据处理的支持。两种类型的向量

可用的处理有:
• 高级 SIMD ,也称为 Neon 。
• Scalable Vector Extension ,缩写为 SVE 。
我们将在稍后的向量编程指南中介绍这两种类型的向量处理。
注意: Advanced SIMD 的名称源于 SIMD 指令的存在在 Armv6 中的常规 32 位通用寄存器上运行。在 Armv7 中,术语高级 SIMD 用于可以对 128 位向量进行操作的指令。这A64 中不存在 Armv6 样式指令,但命名约定保留。



### 加载和存储

基本的加载和存储操作是: LDR (加载)和 STR (存储)。这些操作转移
内存和通用寄存器之间的单个值。这些的语法
说明是:
LDR<符号 >< 尺寸 >  < 目的地 >, [< 地址 >]
STR<尺寸 >  <目的地 >, [< 地址 >]

加载或存储的大小由寄存器类型 X 或 W 和 \<Size\> 字段决定。 X 是用于 32 位, W 用于 64 位。例如,这条指令从  \< 地址 \> 到 W0

LDR W0，[<地址>]

该指令从 \<address\> 加载 64 位到 X0

STRB W0, [\< 地址 \>]

size字段允许您加载子寄存器大小的数据量。例如,这



#### 寻址

加载和存储指令的地址出现在方括号内,如这个例子:
LDR W0, [X1]
有几种寻址模式定义了地址的形成方式。
• 基址寄存器 —— 最简单的寻址形式是单个寄存器。基址寄存器是一个 X 包含被访问数据的完整或绝对虚拟地址的寄存器，可以在这个图中看到:

![Screenshot from 2021-06-01 20-14-30](https://i.loli.net/2021/06/02/zBalcUHJdLkA5of.png)

• 偏移寻址模式 - 可以选择将偏移应用于基地址

![Screenshot from 2021-06-01 20-02-19](https://i.loli.net/2021/06/02/YKvVHTGSMZwn38J.png)

在上图中, X1 包含基地址, #12 是一个字节偏移量地址。这意味着访问的地址是 X1+12 。偏移量可以是
常量或其他寄存器。例如,这种类型的寻址可用于结构。
编译器维护一个指向结构基址的指针,使用偏移量来选择不同的成员。

• 预索引寻址模式 - 在指令语法中,预索引通过添加感叹号 ! 在方括号之后,如下图所示:

![Screenshot from 2021-06-01 20-03-31](https://i.loli.net/2021/06/02/3PNTSG5gD2iYp6W.png)

预变址寻址类似于偏移寻址,除了基指针更新为指令的结果。在上图中, X1 的值在 X1+12 之后指令已完成。

• 索引后寻址模式 - 使用索引后寻址,值从基指针中的地址,然后更新指针,如下图所示:

![Screenshot from 2021-06-01 20-10-52](https://i.loli.net/2021/06/02/OHcJzagSFLt9Piu.png)

后索引寻址对于弹出堆栈很有用。指令加载值从堆栈指针指向的位置开始,然后将堆栈指针移到堆栈中的下一个完整位置。



#### 加载对和存储对

到目前为止,我们已经讨论了单个寄存器的加载和存储。 A64 也有负载 (LDP) 和存储对 (STP) 指令。
这些成对指令将两个寄存器传输到内存和从内存传输。第一条指令加载[X0] 装入 W3 ,并将 [X0 + 4] 装入 W7 :
LDP W3, W7, [X0]

第二条指令将 D0 存储到 [X4] 并将 D1 存储到 [X4 + 8] :

STP D0, D1, [X4]

加载和存储对指令通常用于压入和弹出堆栈。这首先将 X0 和 X1 压入堆栈:

STP X0, X1, [SP, #-16]!

第二条指令从堆栈中弹出 X0 和 X1 :

LDP X0, X1, [SP], #16

请记住,在 AArch64 中,堆栈指针必须是 128 位对⻬的。



#### 浮点寄存器

加载和存储也可以使用浮点寄存器来执行,我们将在这里看到。
第一条指令从 [X0] 加载 64 位到 D1 :
LDR D1, [X0]
第二条指令存储从 Q0 到 [X0 + X1] 的 128 位:
STR Q0, [X0, X1]
最后,此指令从 X5 加载一对 128 位值,然后将 X5 增加 256 :
LDP Q1, Q3, [X5], #256

有一些限制:
• 大小仅由寄存器类型指定。
• 没有签署扩展负载的选项。
• 地址必须仍然是 X 寄存器。
在意外情况下可以找到使用浮点寄存器的加载和存储。很常⻅为 memcpy() 类型例程使用它们。这是因为更广泛的寄存器意味着更少需要迭代。仅仅因为您的代码不使用浮点值,不要假设你不需要使用浮点寄存器。



### 程序流程

#### 循环和决策

在本节中,我们将研究循环和决策如何让您改变您的流程使用分支指令的程序代码。有两种类型的分支指令:
无条件的和有条件的。

**无条件分支指令**

无条件分支指令 B \<label\> 执行直接的、 PC 相关的分支到
< 标签 > 。从当前 PC 到目标的偏移量在指令中编码。
该范围受指令内用于记录偏移量的可用空间的限制,为 +/-
128MB 。
当您使用 BR \<Xn\> 时, BR 执行到指定地址的间接或绝对分支
在 Xn

**条件分支**

条件分支指令 B.\<cond\> \<label\> 是 B 的条件版本
操作说明。仅当条件 \<cond\> 为真时才会采用分支。范围仅限于 +/-
1MB 。
该条件根据存储在 PSTATE 中的 ALU 标志进行测试,并且需要由
之前的指令,例如比较 (CMP) 。
CBZ \<Xn\> < 标签 > 和 CBNZ \<Xn\> < 标签 >
如果 Xn 包含 0 (CBZ) ,则此指令分支到 \<label\> ,如果 Xn 包含,则分支到 label
不包含 0 (CBNZ) 。
TBZ \<Xn\> #\<imm\> \<label\>和 TBNZ \<Xn\> 、 #\<imm\> 、 \<label\>
TBX的工作方式与 CBZ/CBNZ 类似,但测试 \<imm\> 指定的位。

**注意:直接或 PC 相关的分支存储到目标的偏移量操作说明。条件分支的范围更小。这是因为有些位是需要存储条件本身,从而为偏移量留下更少的位。**

![Screenshot from 2021-06-01 20-41-08](https://i.loli.net/2021/06/02/hp7osaKQNbwG1M9.png)



#### 生成条件码

标志是:
• N - 负
• C - 携带
• V - 溢出
• Z - 零
我们以 Z 标志为例。如果操作的结果为零,则设置 Z 标志到 1. 例如,这里如果 X5 为 1 , Z 标志将被设置,否则将被清除:

条件代码映射到这些标志并成对出现。让我们以 EQ (相等)和 NE (不相等)作为例子,看看它们如何映射到 Z 标志:

SUBS W0, W7, W9

W0 = W7 - W9, Z

B.EQ label

在第一行,我们有一个减法运算。在第二行中,如果结果是零。在最后一行中,如果 Z==1 ,则有一个要标记的分支。
如果 w7==w9 ,减法的结果将为零,并且 Z 标志将被设置。
因此,如果 w7 和 w9 相等,将采用标记的分支。
除了常规的数据处理指令外,还有其他指令可用更新 ALU 标志:

CMP - 比较
TST - 测试



#### 条件选择指令

分支  条件选择

![Screenshot from 2021-06-01 20-49-55](https://i.loli.net/2021/06/02/VYCwAiWvN9tGzLm.png)

在这些类型的示例中,条件选择具有一些优势。序列是无论结果如何,都更短并采用相同数量的指令。
重要的是,条件选择还消除了分支的需要。在现代处理器中,这分支预测逻辑很难正确预测哪种分支。一种错误预测的分支会对性能产生负面影响,最好删除尽可能分行





### 函数调用

在调用函数或子例程时,我们需要一种在完成后返回调用者的方法。
在 B 或 BR 指令中添加 L 会将它们变成带有链接的分支。这意味着一个返回地址作为分支的一部分写入 LR (X30) 。
**注意:名称 LR 和 X30 可以互换。汇编程序,例如 GNU GAS 或armclang ,会接受两者。**

有一个专⻔的函数返回指令 RET 。这将执行一个间接分支到链接寄存器中的地址。总之,这意味着我们得到

![Screenshot from 2021-06-01 20-52-06](https://i.loli.net/2021/06/02/TfsqBMY57RtxovL.png)

**注:图中显示了用 GAS 语法汇编器编写的函数 foo() 。关键字.global 导出符号, .type 表示导出的符号是一个函数。**
为什么我们需要一个特殊的函数返回指令?

在功能上, BR LR 会做同样的事情作为 RET 的工作。使用 RET 告诉处理器这是一个函数返回。最现代的
处理器和所有 Cortex-A 处理器都支持分支预测。这是一个函数返回允许处理器更准确地预测分支。
分支预测器猜测程序流将跨越分支的方向。猜测是用于决定将哪些内容加载到管道中,并带有等待处理的指令。如果分支预测器猜测正确,管道有正确的指令和处理器不必等待从内存中加载指令



### 过程调用标准

回顾一下,整数寄存器和浮点寄存器是通用寄存器。然而,如果您希望您的代码与其他人编写的代码进行交互,或者与其他人编写的代码进行交互由编译器生成,那么您需要同意寄存器使用规则。arm体系结构,这些规则称为过程调用标准或 PCS 。
PCS 规定:
• 哪些寄存器用于将参数传递给函数。
• 哪些寄存器用于向执行调用的函数返回值,称为呼叫者。
• 哪个注册被调用的函数,它被称为被调用者,可能会损坏。
• 被调用者不能破坏的寄存器。

考虑一个从 main() 调用的函数 foo() :

![Screenshot from 2021-06-01 20-55-08](https://i.loli.net/2021/06/02/9quTUeDO5ZiJw1I.png)

PCS说第一个参数在 X0 中传递,第二个参数在 X1 中,依此类推
到 X7 。任何进一步的参数都在堆栈上传递。我们的函数 foo() 需要两个参数: b 和 c 。因此, b 将在 W0 中, c 将在 W1 中。
为什么是 W 而不是 X ?因为参数是 32 位类型,因此我们只需要一个 W登记。



接下来，PCS 定义了哪些寄存器可以被破坏，哪些寄存器不能被破坏。 如果某个寄存器可能被损坏，则调用的函数可以覆盖而无需恢复，如以下 PCS 寄存器规则表所示：

![Screenshot from 2021-06-01 20-58-32](https://i.loli.net/2021/06/02/M9kyd68HEsGjufA.png)

例如,函数 foo() 可以使用寄存器 X0 到 X15 而无需保留它们的
值。但是,如果 foo() 要使用 X19 到 X28 ,则必须先将它们保存到堆栈中,然后
在返回之前从堆栈中恢复。
一些寄存器在 PCS 中具有特殊意义:
• XR - 这是一个间接结果寄存器。如果 foo() 返回一个结构体,则内存用于
在前面的示例中, struct 将由调用方 main() 分配。 XR 是指向
调用者为返回结构分配的内存。
• IP0 和 IP1 - 这些寄存器是过程调用内可损坏的寄存器。这些
在调用函数和调用函数的这段时间内,寄存器可能会损坏到达函数中的第一条指令。这些寄存器被链接器用来插入
调用方和被调用方之间的贴面。贴面是一小段代码。最普遍的示例用于分支范围扩展。 A64 中的分支指令范围有限。如果目标超出该范围,则链接器需要生成单板来扩展
分支的范围。
• FP - 帧指针。
• LR - X30 是用于函数调用的链接寄存器 (LR) 。
注意:我们之前介绍了 ALU 标志,用于条件分支和条件选择。 PCS 表示不需要保留 ALU 标志跨函数调用。



### 系统调用

在 A64 中，有进行此类系统调用的特殊指令。 这些指令导致异常，允许受控进入更特权的异常级别。
• SVC - 主管呼叫
导致针对 EL1 的异常。
由应用程序用来调用操作系统。
• HVC - 管理程序调用
导致针对 EL2 的异常。
由操作系统用于调用管理程序，在 EL0 中不可用。
• SMC - 安全监控呼叫
导致针对 EL3 的异常。
由操作系统或管理程序用于调用 EL3 固件，在 EL0 中不可用。
如果从高于目标异常级别的异常级别执行异常，则将异常带到当前的异常级别。 这意味着 EL2 处的 SVC 会导致进入 EL2 的异常。 类似地，EL3 处的 HVC 会导致异常进入 EL3。 这与异常永远不会导致处理器失去特权的规则一致。

































