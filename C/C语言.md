## C语言基础



### 程序运行时内存空间

#### 1.五大分区

<img src="https://uploadfiles.nowcoder.com/images/20190726/55926446_1564117771455_F9A9683572B56150354C5E1B60292A01" alt="img" style="zoom:80%;" />

* **BSS段**属于静态内存分配。BSS节在应用程序的二进制映象文件中并不存在，即不占用磁盘空间而只在运行的时候占用内存空间，所以如果全局变量和静态变量未初始化那么其可执行文件要小很多。
* **数据段**通常用来存放程序中已经初始化的全局变量和静态变量。数据段属于静态内存分配，可以分为只读数据段和读写数据段。字符串常量一般都是放在只读数据段中。
* **代码段**通常是指用来存放程序执行代码。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等，但一般都是放在只读数据段中 。



#### 2.四大分区

静态存储区

&ensp;&ensp;静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在，它主要存放静态变量、全局变量和常量。

注意：

&ensp;&ensp;（1）这里不区分初始化和未初始化的数据区，是因为静态存储区内的变量若不显示初始化，则编译器会自动以默认的方式进行初始化，即静态存储区内不存在未初始化的变量。

&ensp;&ensp;（2）静态存储区内的常量分为常变量和字符串常量，一经初始化，不可修改。

静态存储内的常变量是全局变量，与局部常变量不不同，区别在于局部常变量存放于栈，实际可间接通过指针或者引用进行修改，而全局常变量存放于静态常量区则不可以间接修改。

&ensp;&ensp;（3）字符串常量存储在静态存储区的常量区，字符串常量的名称即为它本身，属于常变量。

&ensp;&ensp;代码区存放程序体的二进制代码。比如我们写的函数，都是在代码区的。



### 变量

*   在没有显式初始化的情况下,外部变量与静态变量默认被初始化为 0;而自动变量与寄存器变量则具有未定义的初值(即无用数据)。行参变量与局部变量一样，在函数被调用时才会分配内存空间，存储在栈中。

*   用static声明局部变量，静态局部变量编译时自动赋初值0，只有第一次才经历变量定义和初始化，以后多次在调用时不再定义和初始化，而是维持上一次调用执行后这个变量的值，且限制只有当前函数可以使用，存储在数据段。

*   全局变量，默认全部源程序文件都可以访问，使用前需要用extern声明，只创造和初始化一次，存储在数据段，未初始化的全局变量存储在BSS段。

*   静态全局变量限制了其作用域， 只在定义该变量的源文件内有效，存储在数据段。

*   字符常量和常变量（const修饰，定义时初始化）都不可更改，存储在静态存储区。



### 函数

*   内部函数（静态函数）

&ensp;&ensp;用static修饰的函数，限制其作用域只在当前源文件可用

*   外部函数

&ensp;&ensp;不加参数的函数默认是外部函数，或者加extern参数，作用域在整个源文件

*   内敛函数

&ensp;&ensp;内联函数通过在函数定义前加inline，内联函数本质上是函数，所以有函数的优点（内联函数是编译器负责处理的，编译器可以帮我们做参数的静态类型检查）；但是他同时也有带参宏的优点（不用调用开销，而是原地展开）。所以几乎可以这样认为：内联函数就是带了参数静态类型检查的宏。

&emsp;&emsp;需要取消位于某些较深的嵌套结构中的处理，例如从两层或者更深的循环中一次性退出来。这种情况不能直接使用break语句，因为它只能退出最内层的循环。这样:

```C
for ( ... )
	for ( ... ) {
		...
		if (disaster)
			goto error;
	}
	...
error:
	错误处理部分
```

&emsp;&emsp;如果相应的错误处理代码不是很少,而且错误会在好几个地方发生,那么这种组织方式会比较便捷。

&emsp;&emsp;标签具有与变量名一样的形式,但其后带有一个冒号。它可指向对应 goto 语句所在函数的任一语句。标签的作用域就是它所在的函数。



一个由C/C++编译的程序占用的内存分为以下几个部分,

1.  栈区（stack）— 由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数（实参）、返回数据、返回地址等。其操作方式类似于数据结构中的栈。 
2.  堆区（heap）— 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS(operating system)回收 。分配方式类似于链表。
3.  全局区（静态区）（static）— 存放全局变量、静态数据、常量。程序结束后由系统释放。
4.  文字常量区 — 常量字符串就是放在这里的。 程序结束后由系统释放。
5.  程序代码区 — 存放函数体（类成员函数和全局函数）的二进制代码

### 堆与栈的比较 　　

#### 3.1申请方式

**stack:**

&emsp;&emsp;由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间。

**heap:**

&emsp;&emsp;需要程序员自己申请，并指明大小，在C中malloc函数，C++中是new运算符。

&emsp;&emsp;如p1 = (char *)malloc(10); p1 = new char[10];

&emsp;&emsp;如p2 = (char *)malloc(10); p2 = new char[20];

&emsp;&emsp;但是注意p1、p2本身是在栈中的。

#### 3.2申请后系统的响应

**stack：**

&emsp;&emsp;只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

**heap：**

&emsp;&emsp;首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。

&emsp;&emsp;对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。

&emsp;&emsp;由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

#### 3.3申请大小的限制

**stack：**

&emsp;&emsp;在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的 ，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

**heap：**

&emsp;&emsp;堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

#### 3.4申请效率的比较　　

**stack：**

&emsp;&emsp;由系统自动分配，速度较快。但程序员是无法控制的。　　

**heap：**

&emsp;&emsp;由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

&emsp;&emsp;另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是栈，而是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。

#### 3.5堆和栈中的存储内容

**stack：**

&emsp;&emsp;在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

**heap：**

&emsp;&emsp;一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

#### 3.6存取效率的比较

&emsp;&emsp;char s1[] = "a";

&emsp;&emsp;char *s2 = "b";

&emsp;&emsp;a是在运行时刻赋值的；而b是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 比如：

```C
int　main() {
	char a = 1;
	char c[] = "1234567890";
	char *p ="1234567890";
	a = c[1];
	a = p[1];
	return 0;
}
```


&emsp;&emsp;对应的汇编代码

```C
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl

11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
```

&emsp;&emsp;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。

#### 3.7小结

&emsp;&emsp;堆和栈的主要区别由以下几点：

1.  管理方式不同；

2.  空间大小不同；

3.  能否产生碎片不同；

4.  生长方向不同；

5.  分配方式不同；

6.  分配效率不同；　　


**管理方式：**

&emsp;&emsp;对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

 **空间大小：**

&emsp;&emsp;一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。

**碎片问题：**

&emsp;&emsp;对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问 题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详 细的可以参考数据结构。

**生长方向：**

&emsp;&emsp;对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

**分配方式：**

&emsp;&emsp;堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

**分配效率：**

&emsp;&emsp;栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效 率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统） 在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机 会分 到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

&emsp;&emsp;从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用 户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。

&ensp;&ensp;虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。

&emsp;&emsp;无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。