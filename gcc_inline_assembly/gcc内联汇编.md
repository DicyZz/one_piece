gcc内联汇编

__asm__("Instruction List" : Output : Input : Clobber/Modify);

1.如果Clobber/Modify为空，则其前面的冒号(:)必须省略。
2.如果Output，Input，Clobber/Modify都为空，Output、Input之前的冒号(:)既可以省略，也可以不省略。
如果都省略，则此汇编退化为一个基本内联汇编，否则，仍然是一个带有C/C++表达式的内联汇编。
3.如果Input，Clobber/Modify为空，但Output不为空，Input前的冒号(:)既可以省略，也可以不省略。
4.如果后面的部分不为空，而前面的部分为空，则前面的冒号(:)都必须保留，否则无法说明不为空的部分究竟是第几部分。
比如，Clobber/Modify，Output为空，而Input不为空，则Clobber/Modify前的冒号必须省略（前面的规则），而Output前的冒号必须为保留。
如果Clobber/Modify不为空，而Input和Output都为空，则Input和Output前的冒号都必须保留。


Output(输出操作数)：
输出操作由两部分组成：括号括住的部分(cr0)和引号引住的部分"=a"。这两部分都是每一个输出操作必不可少的。
括号括住的部分是一个C/C++表达式，用来保存内联汇编的一个输出值，其操作就等于C/C++的相等赋值cr0=output_value，
因此，括号中的输出表达式只能是C/C++的左值表达式，也就是说它只能是一个可以合法的放在C/C++赋值操作中等号(=)左边的表达式。那么右值output_value从何而来呢？
答案是引号中的内容，被称作“操作约束”（OperationConstraint），在这个例子中操作约束为"=a"，它包含两个约束：等号(=)和字母a，
其中等号(=)说明括号中左值表达式cr0是一个Write-Only的，只能够被作为当前内联汇编的输入，而不能作为输入。
而字母a是寄存器EAX/AX/AL的简写，说明cr0的值要从eax寄存器中获取，也就是说cr0=eax，最终这一点被转化成汇编指令就是movl %eax, address_of_cr0。
现在你应该清楚了吧，操作约束中会给出：到底从哪个寄存器传递值给cr0。
另外，需要特别说明的是，很多文档都声明，所有输出操作的操作约束必须包含一个等号(=)，但GCC的文档中却很清楚的声明，并非如此。
因为等号(=)约束说明当前的表达式是一个Write-Only的，但另外还有一个符号——加号(+)用来说明当前表达式是一个Read-Write的，如果一个操作约束中没有给出这两个符号中的任何一个，
则说明当前表达式是Read-Only的。因为对于输出操作来说，肯定是必须是可写的，而等号(=)和加号(+)都表示可写，只不过加号(+)同时也表示是可读的。
所以对于一个输出操作来说，其操作约束只需要有等号(=)或加号(+)中的任意一个就可以了。


Input(输入操作数)：
一个输入表达式也分为两部分：带括号的部分(cpu->db7)和带引号的部分"a"。这两部分对于一个内联汇编输入表达式来说也是必不可少的。
括号中的表达式cpu->db7是一个C/C++语言的表达式，它不必是一个左值表达式，也就是说它不仅可以是放在C/C++赋值操作左边的表达式，还可以是放在C/C++赋值操作右边的表达式。
所以它可以是一个变量，一个数字，还可以是一个复杂的表达式（比如a+b/c*d）。比如上例可以改为： 
__asm__("movl %0, %%db7" : : "a" (foo))，
__asm__("movl %0, %%db7" : : "a" (0x1000))或
__asm__("movl %0, %%db7" : : "a" (va*vb/vc))。
引号号中的部分是约束部分，和输出表达式约束不同的是，它不允许指定加号(+)约束和等号(=)约束，也就是说它只能是默认的Read-Only的。
约束中必须指定一个寄存器约束，例中的字母a表示当前输入变量cpu->db7要通过寄存器eax输入到当前内联汇编中。

寄存器约束
当你当前的输入或输入需要借助一个寄存器时，你需要为其指定一个寄存器约束。你可以直接指定一个寄存器的名字，比如：
__asm__ __volatile__("movl %0, %%cr0"::"eax" (cr0));
也可以指定一个缩写，比如：
__asm__ __volatile__("movl %0, %%cr0"::"a" (cr0));
如果你指定一个缩写，比如字母a，则GCC将会根据当前操作表达式中C/C++表达式的宽度决定使用%eax，还是%ax或%al。比如：
unsigned short __shrt;
__asm__ ("mov %0，%%bx" : : "a"(__shrt));
由于变量__shrt是16-bit short类型，则编译出来的汇编代码中，则会让此变量使用%ex寄存器。

下表中列出了常用的寄存器约束的缩写。
约束 Input/Output 意义 r I,O 表示使用一个通用寄存器，由GCC在%eax/%ax/%al, %ebx/%bx/%bl, %ecx/%cx/%cl, %edx/%dx/%dl中选取一个GCC认为合适的。
m : 允许一个内存操作数使用机器普遍支持的任一种地址。
o : 允许一个内存操作数，但只有当地址是可偏移的。即，该地址加上一个小的偏移量可以得到一个地址。
V : A memory operand that is not offsettable. In other words, anything that would fit the m constraint but not the o constraint.
i : 允许一个（带有常量）的立即整形操作数。这包括其值仅在汇编时期知道的符号常量。
n : 允许一个带有已知数字的立即整形操作数。许多系统不支持汇编时期的常量，因为操作数少于一个字宽。对于此种操作数，约束应该使用 n 而不是 i。
g : 允许任一寄存器、内存或者立即整形操作数，不包括通用寄存器之外的寄存器。
x86特有：
r : 寄存器操作数约束，查看上面给定的表格。
q : 寄存器 a、b、c 或者 d。
I : 范围从 0 到 31 的常量（对于 32 位移位）。
J : 范围从 0 到 63 的常量（对于 64 位移位）。
K : 0xff。
L : 0xffff。
M : 0, 1, 2, or 3 （lea 指令的移位）。
N : 范围从 0 到 255 的常量（对于 out 指令）。
f : 浮点寄存器
t : 第一个（栈顶）浮点寄存器
u : 第二个浮点寄存器
A : 指定 a 或 d 寄存器。这主要用于想要返回 64 位整形数，使用 d 寄存器保存最高有效位和 a 寄存器保存最低有效位。 
0,1,2,3,4,5,6,7,8,9 I 表示和第n个操作表达式使用相同的寄存器/内存。


Clobber/Modify(修饰寄存器列表):
一些指令会破坏一些硬件寄存器。我们不得不在修饰寄存器中列出这些寄存器，即汇编函数内第三个 : 之后的域。
这可以通知 gcc 我们将会自己使用和修改这些寄存器。所以 gcc 将不会假设存入这些寄存器的值是有效的。我们不用在这个列表里列出输入输出寄存器。
因为 gcc 知道 asm 使用了它们（因为它们被显式地指定为约束了）。

如果指令隐式或显式地使用了任何其他寄存器，（并且寄存器不能出现在输出或者输出约束列表里），那么不得不在修饰寄存器列表中指定这些寄存器。
如果我们的指令可以修改状态寄存器，我们必须将 cc 添加进修饰寄存器列表。
如果我们的指令以不可预测的方式修改了内存，那么需要将 memory 添加进修饰寄存器列表。
这可以使 GCC 不会在汇编指令间保持缓存于寄存器的内存值。如果被影响的内存不在汇编的输入或输出列表中，我们也必须添加 volatile 关键词。


如果我们的汇编语句必须在我们放置它的地方执行（即，不能作为一种优化被移出循环语句） volatile


一、关键字 
如何让 GCC 知道代码中内嵌的汇编呢？ 借助关键字！来看下面的例子： 

__asm__ __volatile__("hlt"); 

__asm__ 表示后面的代码为内嵌汇编，asm 是 __asm__ 的别名。__volatile__ 表示编译器不要优化代码，后面的指令保留原样，volatile 是它的别名。括号里面是汇编指令。 

二、示例分析 
使用内嵌汇编，要先编写汇编指令模板，然后将 C 语言表达式与指令的操作数相关联，并告诉 GCC 对这些操作有哪些限制条件。示例如下： 

__asm__ __violate__ ("movl %1,%0" : "=r" (result) : "m" (input)); 

movl %1,%0 是指令模板；%0 和 %1 代表指令的操作数，称为占位符，内嵌汇编靠它们将C 语言表达式与指令操作数相对应。 

指令模板后面用小括号括起来的是 C 语言表达式，本例中只有两个：result 和 input ，他们按照出现的顺序分别与指令操作数 %0 、%1 对应；
注意对应顺序：第一个 C 表达式对应 %0 ；第二个表达式对应 %1 ，依次类推，操作数至多有10 个，分别用 %0, %1 …. %9 表示。 

在每个操作数前面有一个用引号括起来的字符串，字符串的内容是对该操作数的限制或者说要求。
result 前面的限制字符串是 =r ，其中 = 表示 result 是输出操作数， r 表示需要将 result 与某个通用寄存器相关联，
先将操作数的值读入寄存器，然后在指令中使用相应寄存器，而不是 result 本身，当然指令执行完后需要将寄存器中的值存入变量 result ，
从表面上看好像是指令直接对 result 进行操作，实际上 GCC 做了隐式处理，这样我们可以少写一些指令。 
input 前面的 r 表示该表达式需要先放入某个寄存器，然后在指令中使用该寄存器参加运算。 

C 表达式或者变量与寄存器的关系由 GCC 自动处理，我们只需使用限制字符串指导 GCC 如何处理即可。
限制字符必须与指令对操作数的要求相匹配，否则产生的汇编代码将会有错，读者可以将上例中的两个 r，都改为 m (m表示操作数放在内存，而不是寄存器中)，编译后得到的结果是： 

movl input, result 

很明显这是一条非法指令，因此限制字符串必须与指令对操作数的要求匹配。例如指令 movl 允许寄存器到寄存器，立即数到寄存器等，
但是不允许内存到内存的操作，因此两个操作数不能同时使用 m 作为限定字符。 
内嵌汇编语法如下： 

__asm__(汇编语句模板: 输出部分: 输入部分: 破坏描述部分) 

共四个部分：汇编语句模板，输出部分，输入部分，破坏描述部分，各部分使用“:”格开，汇编语句模板必不可少，其他三部分可选，
如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。例如： 

__asm__ __volatile__("cli": : :"memory") 

具体这几部分都有什么限制呢？这得从细处着手！


三、语法细节 
1、汇编语句模板 
汇编语句模板由汇编语句序列组成，语句之间使用“;”、“\n” 或 “\n\t” 分开。指令中的操作数可以使用占位符引用 C 语言变量，
操作数占位符最多10 个，名称如下：%0，%1，…，%9。指令中使用占位符表示的操作数，总被视为 long 型（4个字节），但对其施加的操作根据指令可以是字或者字节，
当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节 还是次字节。方法是在 % 和序号之间插入一个字母，b 代表低字节，h 代表高字节，
例如：%h1。 

2、输出部分 
输出部分描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C语言变量组成。每个输出操作数的限定字符串必须包含“=”表示他是一个输出操作数。 例如： 

__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x) ) 

描述符字符串表示对该变量的限制条件，这样 GCC 就可以根据这些条件决定如何分配寄存器，如何产生必要的代码处理指令操作数与 C 表达式或 C 变量之间的联系。 

3、输入部分 
输入部分描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符由限定字符串和 C 语言表达式或者 C 语言变量组成。 示例如下: 

例 1 ： 
__asm__ __volatile__ ("lidt %0" : : "m" (real_mode_idt)); 

例 2： 
Static __inline__ void __set_bit(int nr, volatile void * addr) 
{ 
__asm__( 
	"btsl %1,%0" 
	:"=m" (ADDR) 
	:"Ir" (nr)); 
} 

后例功能是将 (*addr) 的第 nr 位设为 1。第一个占位符 %0 与 C 语言变量 ADDR 对应，第二个占位符 %1 与 C语言变量 nr 对应。
因此上面的汇编语句代码与下面的伪代码等价：btsl nr, ADDR，该指令的两个操作数不能全是内存变量，因此将 nr 的限定字符串指定为“Ir”，
将 nr 与立即数或者寄存器相关联，这样两个操作数中只有ADDR 为内存变量。 

4、限制字符 
限制字符有很多种，有些是与特定体系结构相关，此处仅列出常用的限定字符和i386中可能用到的一些常用的限定符。它们的作用是指示编译器如何处理其后的 C 语言变量与指令操作数之间的关系。 



分类 				限定符  				描述 
通用寄存器 			“a” 					将输入变量放入eax 
					“b” 					将输入变量放入ebx 
					“c” 					将输入变量放入ecx 
					“d” 					将输入变量放入edx 
					“s” 					将输入变量放入esi 
					“d” 					将输入变量放入edi 
					“q” 					将输入变量放入eax，ebx，ecx，edx中的一个 
					“r” 					将输入变量放入通用寄存器,即eax,ebx,ecx,edx,esi,edi之一 
					“A” 					把eax和edx合成一个64 位的寄存器(use long longs) 
内存 
					“m” 					内存变量 
					“o” 					操作数为内存变量，但其寻址方式是偏移量类型, 也即基址寻址 
					“V” 					操作数为内存变量，但寻址方式不是偏移量类型 
					“ ” 					操作数为内存变量，但寻址方式为自动增量 
					“p” 					操作数是一个合法的内存地址（指针） 
寄存器或内存 
					“g” 					将输入变量放入eax，ebx，ecx，edx之一,或作为内存变量 
					“X” 					操作数可以是任何类型 
立即数 
					“I” 					0-31之间的立即数（用于32位移位指令） 
					“J” 					0-63之间的立即数（用于64位移位指令） 
					“N” 					0-255之间的立即数（用于out指令） 
					“i” 					立即数 
					“n” 					立即数,有些系统不支持除字以外的立即数,则应使用“n”而非 “i” 
匹配 
					“0”						表示用它限制的操作数与某个指定的操作数匹配 
					“1” ... 				也即该操作数就是指定的那个操作数，例如“0” 
					“9” 				去描述“％1”操作数，那么“%1”引用的其实就是“%0”操作数，注意作为限定符字母的0－9 与指令中的“％0”－“％9”的区别，前者描述操作数, 后者代表操作数。 
					& 						该输出操作数不能使用过和输入操作数相同的寄存器 
操作数类型 
					“=” 					操作数在指令中是只写的（输出操作数） 
					“+” 					操作数在指令中是读写类型的（输入输出操作数） 
浮点数 
					“f” 					浮点寄存器 
					“t” 					第一个浮点寄存器 
					“u” 					第二个浮点寄存器 
					“G” 					标准的80387浮点常数 
					% 				该操作数可以和下一个操作数交换位置,例如addl的两个操作数可以交换顺序（当然两个操作数都不能是立即数） 
					# 						部分注释，从该字符到其后的逗号之间所有字母被忽略 
					* 						表示如果选用寄存器，则其后的字母被忽略 


5、破坏描述部分 
破坏描述符用于通知编译器我们使用了哪些寄存器或内存，由逗号格开的字符串组成，每个字符串描述一种情况，一般是寄存器名；除寄存器外还有 “memory”。例如：“%eax”，“%ebx”，“memory” 等。








                                                      
